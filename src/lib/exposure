import { prisma } from '@/lib/db'

type Num = number | null | undefined
const n = (x: Num) => Number(x ?? 0)

export type ExposureOverview = {
  since?: string
  pendingTotal: number
  pnlTotal: number
  bySport: Array<{ sport: string; pending: number; pnl: number }>
  byMarket: Array<{ market: string; pending: number; pnl: number }>
}

export async function getExposureOverview(days?: number): Promise<ExposureOverview> {
  const since = days ? new Date(Date.now() - days * 86_400_000) : undefined
  const dateFilter = since ? { gte: since } : undefined

  // Overall pending exposure (risk currently on)
  const pendingAgg = await prisma.bet.aggregate({
    where: { status: 'pending', ...(dateFilter ? { createdAt: dateFilter } : {}) },
    _sum: { stakeUnits: true },
  })

  // Overall realized PnL (settled bets)
  const pnlAgg = await prisma.bet.aggregate({
    where: {
      status: { in: ['win', 'loss', 'void'] },
      ...(dateFilter ? { createdAt: dateFilter } : {}),
    },
    _sum: { realizedUnits: true },
  })

  // By sport — pending
  const pendingBySport = await prisma.bet.groupBy({
    by: ['sport'],
    where: { status: 'pending', ...(dateFilter ? { createdAt: dateFilter } : {}) },
    _sum: { stakeUnits: true },
    orderBy: { sport: 'asc' },
  })

  // By sport — pnl
  const pnlBySport = await prisma.bet.groupBy({
    by: ['sport'],
    where: { status: { in: ['win', 'loss', 'void'] }, ...(dateFilter ? { createdAt: dateFilter } : {}) },
    _sum: { realizedUnits: true },
    orderBy: { sport: 'asc' },
  })

  // Merge sport rows
  const sportMap = new Map<string, { sport: string; pending: number; pnl: number }>()
  for (const row of pendingBySport) {
    const key = row.sport
    sportMap.set(key, { sport: key, pending: n(row._sum.stakeUnits), pnl: 0 })
  }
  for (const row of pnlBySport) {
    const key = row.sport
    const existing = sportMap.get(key) ?? { sport: key, pending: 0, pnl: 0 }
    existing.pnl += n(row._sum.realizedUnits)
    sportMap.set(key, existing)
  }

  // By market — pending
  const pendingByMarket = await prisma.bet.groupBy({
    by: ['market'],
    where: { status: 'pending', ...(dateFilter ? { createdAt: dateFilter } : {}) },
    _sum: { stakeUnits: true },
    orderBy: { market: 'asc' },
  })

  // By market — pnl
  const pnlByMarket = await prisma.bet.groupBy({
    by: ['market'],
    where: { status: { in: ['win', 'loss', 'void'] }, ...(dateFilter ? { createdAt: dateFilter } : {}) },
    _sum: { realizedUnits: true },
    orderBy: { market: 'asc' },
  })

  // Merge market rows (coalesce null to '—')
  const marketMap = new Map<string, { market: string; pending: number; pnl: number }>()
  for (const row of pendingByMarket) {
    const key = row.market ?? '—'
    marketMap.set(key, { market: key, pending: n(row._sum.stakeUnits), pnl: 0 })
  }
  for (const row of pnlByMarket) {
    const key = row.market ?? '—'
    const existing = marketMap.get(key) ?? { market: key, pending: 0, pnl: 0 }
    existing.pnl += n(row._sum.realizedUnits)
    marketMap.set(key, existing)
  }

  return {
    since: since?.toISOString(),
    pendingTotal: n(pendingAgg._sum.stakeUnits),
    pnlTotal: n(pnlAgg._sum.realizedUnits),
    bySport: Array.from(sportMap.values()).sort((a, b) => a.sport.localeCompare(b.sport)),
    byMarket: Array.from(marketMap.values()).sort((a, b) => a.market.localeCompare(b.market)),
  }
}
